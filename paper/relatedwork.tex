\section{Related Work}
\label{sec:relatedwork}

\paragraph{Memory Allocation Profiling} Many works claim to profile memory allocations. Mprof~\cite{Zorn:1988:MAP:894814} collects the information about allocations and deallocations, reports memory leaks, an allocation bin table, and a direct allocation table that shows the memory usage of functions. Its allocation bin table provides information about different sizes and their corresponding program types, such that programmers may focus on data structures that consume the most memory. Mtrace~\cite{mtrace}, while Mtrace++~\cite{Lee:2000:DMM:786772.787150} traces the allocation events and  reports possible memory leaks. Mtrace++ further identifies the origins of allocated memory and the life spans of objects. TcMalloc includes a profiler that can report the heap state dynamically, locate memory leaks, and identify statements with a large number of allocations~\cite{tcmalloc}. Chang et. al. further profile the allocation behavior inside Android applications~\cite{7031343}. MemoryProfiler shows memory consumption of different types (e.g., Java, Native) and different objects, timeline information of allocations, garbage collection events, and the stack trace of each allocation inside Android applications~\cite{MemoryProfiler}. WMTrace monitors allocation and deallocation events, together with their timing information~\cite{Perks:2011:WAP:2186355.2186369}. WMTrace also compresses the trace, and writes to storage files. LeakPoint detects memory leaks of different size classes~\cite{Clause:2010:LPC:1806799.1806874}.However, they mainly focus on the behavior of memory allocations and deallocations of applications, but reveals nothing about the allocator itself. They cannot be utilized to identify design issues within the allocator, and cannot tell whether the allocator is the culprit of performance and memory issues, which is significantly different from \MP{}. 

\paragraph{General Profilers} There exist many general profilers that could help identify the performance issues of applications, such as  gprof~\cite{DBLP:conf/sigplan/GrahamKM82}, Oprofile~\cite{levon2004oprofile}, Coz~\cite{Coz}, and Perf~\cite{perf}. gprof instruments code at the entry and exit point of every functions, so that it can report the runtime and invocation of every function~\cite{DBLP:conf/sigplan/GrahamKM82}. However, gprof requires the instrumentation beforehand, which may miss issues inside a library if it is not instrumented. Both Oprofile~\cite{levon2004oprofile} and Perf~\cite{perf} utilize hardware performance counters to collect the details of an execution; they can produce call graphs, and collect some kernel events as well. However, they will require significant manual effort to diagnose the issues associated with an allocator. Coz employs the virtual speedup technique to quantify the performance impact of a line or a range of lines~\cite{Coz}. Overall, they typically focus on applications' performance issues, providing no insights into issues inside the allocator without collecting the data related to memory management. They cannot provide values for the memory overhead, scalability, or application-friendliness of allocators, all of which \MP{} reports.


\paragraph{Study of Memory Allocators} There exist multiple studies from the past dealing with the study of different memory allocators. Barroso et al. present a performance study on commercial workloads with different memory systems~\cite{Barroso:1998:MSC:279358.279363}. Chihaia et al. develop two analytical models to evaluate the performance impact on large applications, based on an application's interaction with the memory system\cite{1291361}. Some evaluate the response time, memory consumption, and memory fragmentation of popular allocators with different numbers of cores on a set of applications~\cite{6084042, ferreira2011comparison}. 
%Zavrtanik et. al. evaluate the runtime, memory consumption, and scalability of multiple allocators~\cite{zavrtanikexperimental}. 
However, they can only report some observable behavior of different allocators, providing no insight about the specific issues inside of the allocators. 



 %The observation is that a regular application has continuous and stride memory accesses, while an irregular application has three memory access types: continuous accesses, accesses within the same L1/L2 cache line, and random accesses. This is actually not that related to our system. 

%https://www.bsdcan.org/2006/papers/jemalloc.pdf



