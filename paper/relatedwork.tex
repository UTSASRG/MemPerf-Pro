\section{Related Work}
\label{sec:relatedwork}

\paragraph{Study of Memory Allocators} There exist multiple studies in the past. Some evaluate the response time, memory consumption, and memory fragmentation of  popular allocators with different number of cores~\cite{6084042, ferreira2011comparison}. Zavrtanik et. al. evaluates the runtime, memory consumption, scalability of multiple allocators~\cite{zavrtanikexperimental}. However, they typically run a set of applications, and then report some observable behavior of different allocators. However, they do not design a general profiler that cannot tell the specific issues inside the allocators. For instance, they cannot tell where memory overhead is from, and why the allocator is not scalable. 


\subsection{Allocation Profiling} Existing work claims to profiling allocations mainly focuses on the behavior of memory allocations and deallocations for different applications. Mtrace~\cite{mtrace} traces the events of \texttt{malloc}, \texttt{realloc}, and \texttt{free}, and then post-proposes them. Mtrace reports possible memory leaks. Mtrace++~\cite{Lee:2000:DMM:786772.787150} is a source-code level instrumentation that traces the memory allocations and deallocations. Mtrace++ identifies originations of allocated memories and life spans of objects. But it cannot point out whether problems may occur inside allocations. 
Mprof~\cite{Zorn:1988:MAP:894814} first collects the information about allocations and deallocations and writes the information into a file. It reports memory leaks, an allocation bin table, a direct allocation table that shows memory usage of functions, and a dynamic call graph. The allocation bin table provides information about what sizes of objects were allocated, and what program types correspond to the sizes listed, so that programmers could figure out data structures that consume the most memory. 
TcMalloc includes a profiler to profile the memory usage of C/C++ applications~\cite{ghemawat2007tcmalloc}. It could report the heap state at a given time, locate the memory leaks inside applications, and identify statements with a large number of allocations. Although the information is helpful in improving the performance of applications, it tells nothing about the allocator itself. Chang et. al. further profiles the allocation behavior inside Android applications, \todo{such as XXX}~\cite{7031343}. MemoryProfiler shows memory consumption of different types (e.g., Java, Native) and different objects, timeline information of allocations, garbage collection events, stack trace of each allocations inside Android applications~\cite{MemoryProfiler}. 

\subsection{Memory Allocator}

\cite{1291361} develops two analytical models to evaluate the performance impact on large application, based on an application's interaction with the memory system. The observation is that a regular application has continuous and stride memory accesses, while an irregular application has three memory access types: continuous accesses, accesses within the same L1/L2 cache line, and random accesses. This is actually not that related to our system. 

%Potential projects: is there possible to monitor memory accesses pattern and then report irregular pattern and report problems with call site information. 

\cite{Barroso:1998:MSC:279358.279363}: This paper presents a performance study of some  commercial workloads and characterizes the memory system behavior of these workloads, in order to determine the impact of architectural trends.

% through a large number of architectural experiments on Alpha multiprocessors augmented with full system simulations to determine the impact of architectural trends. We also identify a set of simplifications that make these workloads more amenable to monitoring and simulation without affecting representative memory system behavior. We observe that systems optimized for OLTP versus DSS and index search workloads may lead to diverging designs, specifically in the size and speed requirements for off-chip caches.


% The direct allocation table shows which functions allocate memory and how much they allocate. Mprof introduces around $2\times$ performance overhead that makes it unsuitable for deployment cases. 

\MP{} points out the problem related to the behavior of memory allocation, in which the performance can be improved by changing the behavior of memory allocations, not internal data structure. 
  


\cite{846583}

\cite{1190248}


%https://www.bsdcan.org/2006/papers/jemalloc.pdf
WMTrace monitors malloc, calloc, realloc, and free events, together with their timing information~\cite{Perks:2011:WAP:2186355.2186369}. WMTrace also compresses the trace, and writes to storage files. 
 

LeakPoint detects memory leaks of different size classes~\cite{Clause:2010:LPC:1806799.1806874}.

\paragraph{General Profiler} There exists many general profilers that could help identify the performance issues of applications, such as  gprof~\cite{DBLP:conf/sigplan/GrahamKM82}, Coz~\cite{Coz}, and perf~\cite{perf}. However, they typically focuses on application's performance issue, providing no insights for performance issue inside the allocator. For instance, gprof  reports the percentage of time spent in different functions, the number of invocations. However, they cannot report why the percentage of time   
even they could identify the percentage of time in allocations and deallocations, they . 

Coz, 

Perf, 
Gprof,

