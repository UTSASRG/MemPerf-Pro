\section{Related Work}
\label{sec:relatedwork}

\paragraph{Memory Allocation Profiling} A lot of work claims to profile memory allocations. Mprof~\cite{Zorn:1988:MAP:894814} collects the information about allocations and deallocations, reports memory leaks, an allocation bin table, and a direct allocation table that shows memory usage of functions. Its allocation bin table provides information about different sizes and their corresponding program types, so that programmers could focus on data structures that consume the most memory. Mtrace~\cite{mtrace} and Mtrace++~\cite{Lee:2000:DMM:786772.787150} traces the allocation events, and then reports possible memory leaks. Mtrace++ further identifies originations of allocated memories and life spans of objects. TcMalloc includes a profiler that could report the heap state dynamically, locate the memory leaks, and identify statements with a large number of allocations~\cite{tcmalloc}.  Chang et. al. further profiles the allocation behavior inside Android applications~\cite{7031343}. MemoryProfiler shows memory consumption of different types (e.g., Java, Native) and different objects, timeline information of allocations, garbage collection events, stack trace of each allocations inside Android applications~\cite{MemoryProfiler}. WMTrace monitors allocation and deallocation events, together with their timing information~\cite{Perks:2011:WAP:2186355.2186369}. WMTrace also compresses the trace, and writes to storage files. LeakPoint detects memory leaks of different size classes~\cite{Clause:2010:LPC:1806799.1806874}.However, they mainly focus on the behavior of memory allocations and deallocations of applications, but tells nothing about the allocator itself. They cannot be utilized to identify design issues inside the allocator, and cannot tell whether the allocator is the culprit of performance and memory issues, which is significantly from \MP{}. 

\paragraph{General Profiler} There exists many general profilers that could help identify the performance issues of applications, such as  gprof~\cite{DBLP:conf/sigplan/GrahamKM82}, Oprofile~\cite{levon2004oprofile}, Coz~\cite{Coz}, and Perf~\cite{perf}. gprof instruments code at the entry and exit of every functions, so that it can report the runtime and invocation of every function~\cite{DBLP:conf/sigplan/GrahamKM82}. However, gprof requires the instrumentation beforehand, which may miss the issues inside a library if it is not instrumented.  Both Oprofile~\cite{levon2004oprofile} and Perf~\cite{perf} utilize hardware performance counters to collect the details of an execution. They could produce call graphs, and collect some kernel events as well. However, they will require significant manual effort to diagnose the issues of an allocator. Coz employs the virtual speedup technique to quantify the performance impact of a line or a range of lines~\cite{Coz}. Overall, they typically focuses on application's performance issue, providing no insights for issues inside the allocator without collecting the data related to memory management. They cannot answer the memory overhead, scalability, and application-friendliness of allocators that \MP{} reports.


\paragraph{Study of Memory Allocators} There exist multiple studies in the past for study different allocators. Barroso et al. present a performance study on  commercial workloads with different memory systems~\cite{Barroso:1998:MSC:279358.279363}. Chihaia et al. develops two analytical models to evaluate the performance impact on large application, based on an application's interaction with the memory system\cite{1291361}. Some evaluate the response time, memory consumption, and memory fragmentation of popular allocators with different number of cores on a set of applications~\cite{6084042, ferreira2011comparison}. Zavrtanik et. al. evaluates the runtime, memory consumption, scalability of multiple allocators~\cite{zavrtanikexperimental}. 
However, they can only report some observable behavior of different allocators, providing no insight about the specific issues inside the allocators. 



 %The observation is that a regular application has continuous and stride memory accesses, while an irregular application has three memory access types: continuous accesses, accesses within the same L1/L2 cache line, and random accesses. This is actually not that related to our system. 

%https://www.bsdcan.org/2006/papers/jemalloc.pdf



