\section{Performance Impact of Memory Allocators}

This section will give an overview on how a memory allocator could significantly impact the performance. By default, we assume that the allocator supports multithreaded applications, since it is much easier to analyze the performance impact for single threaded applications. 

\subsection{Contention}

One major reason on the performance impact. 

In fact, there are two types of contention on the memory allocator: user space contention and kernel space contention. 

User space contention typically consists of the lock contention inside the user space. Some allocators utilize one global lock for all threads, which could significantly affect the performance of multithreaded applications. All threads could be serialized inside the memory allocator. 

More specifically, we are planning to utilize the blocking time as a parameter to evaluate the user space contention. 

Kernel space contention will be another type of contention of memory allocators. For example, glibc allocator will return the memory back to the OS when the available virtual memory is beyond one threshold. 

Therefore, it is also very important to measure the kernel space contention for memory allocators. We could utilize the additional blocking time as a parameter. 



\subsection{Allocation/Deallocation Condition} 

How much time spent in the allocation? 
How much time spent in the deallocation? 

How much page fault? 

\subsection{Cache Effect of Allocation/Deallocation}

We don't focus on which object has false sharing and true sharing.
But we will check how much empty of each allocation and deallocation. 

 


