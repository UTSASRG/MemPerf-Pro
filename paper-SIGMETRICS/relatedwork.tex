\section{Related Work}
\label{sec:relatedwork}

\paragraph{Memory Allocation Profiling} Many papers claim to profile memory allocations. Mprof~\cite{Zorn:1988:MAP:894814} collects the information about allocations and deallocations, reports memory leaks, an allocation bin table, and a direct allocation table that shows the memory usage of functions. 
%Its allocation bin table provides information about different sizes and their corresponding program types, such that programmers may focus on data structures that consume the most memory. 
Mtrace~\cite{mtrace} and Mtrace++~\cite{Lee:2000:DMM:786772.787150} traces the allocation events and reports possible memory leaks. Mtrace++ further identifies the origins of allocated memory and the life spans of objects. TcMalloc's profiler reports the heap state dynamically, locate memory leaks, and identify statements with a large number of allocations~\cite{tcmalloc}. Chang et. al.  profile allocation behavior of Android applications~\cite{7031343}. MemoryProfiler shows memory consumption of different types (e.g., Java, Native) and different objects, timeline information of allocations, garbage collection events, and the stack trace of each allocation inside Android applications~\cite{MemoryProfiler}. WMTrace monitors allocation and deallocation events, together with their timing information~\cite{Perks:2011:WAP:2186355.2186369}. WMTrace also compresses the trace, and writes to storage files. LeakPoint detects memory leaks of different size classes~\cite{Clause:2010:LPC:1806799.1806874}. However, they mainly focus on the behavior of memory allocations and deallocations of applications. They cannot identify design issues within the allocator, which is significantly different from \MP{}. 

\paragraph{General Profilers} There exist many general profilers that could help identify the performance issues of applications, such as  gprof~\cite{DBLP:conf/sigplan/GrahamKM82}, Oprofile~\cite{levon2004oprofile}, Coz~\cite{Coz}, and Perf~\cite{perf}. 
%gprof instruments code at the entry and exit point of every functions, so that it can report the runtime and invocation of every function~\cite{DBLP:conf/sigplan/GrahamKM82}. However, gprof requires the instrumentation beforehand, which may miss issues inside a library if it is not instrumented. Both Oprofile~\cite{levon2004oprofile} and Perf~\cite{perf} utilize hardware performance counters to collect the details of an execution; they can produce call graphs, and collect some kernel events as well. However, they will require significant manual effort to diagnose the issues associated with an allocator. Coz employs the virtual speedup technique to quantify the performance impact of a line or a range of lines~\cite{Coz}.
As discussed in Section~\ref{sec:intro}, they typically focus on performance issues of applications, providing no insights of the allocators. 
%They cannot provide values for the memory overhead, scalability, or application-friendliness of allocators, all of which \MP{} reports.

\paragraph{Study of Memory Allocators} There exist multiple studies that investigate of different memory allocators~\cite{Barroso:1998:MSC:279358.279363, 1291361, 6084042, ferreira2011comparison,  zavrtanikexperimental}.
%Barroso et al. present a performance study on commercial workloads with different memory systems~\cite{Barroso:1998:MSC:279358.279363}. Chihaia et al. develop two analytical models to evaluate the performance impact on large applications, based on an application's interaction with the memory system\cite{1291361}. Some evaluate the response time, memory consumption, and memory fragmentation of popular allocators with different numbers of cores on a set of applications~\cite{6084042, ferreira2011comparison}. 
%Zavrtanik et. al. evaluate the runtime, memory consumption, and scalability of multiple allocators~\cite{zavrtanikexperimental}. 
However, they can only report some observable behavior of evaluated allocators, providing no insight about the specific issues inside of the allocators. They could not report memory overhead caused by an allocator as well. 



 %The observation is that a regular application has continuous and stride memory accesses, while an irregular application has three memory access types: continuous accesses, accesses within the same L1/L2 cache line, and random accesses. This is actually not that related to our system. 

%https://www.bsdcan.org/2006/papers/jemalloc.pdf



